# 11. 理论：卷积网络

![](https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/img/53c160301db12a6e.png)

在卷积网络层中，一个**神经元**仅对该图像上的一个小部分的像素求加权和。然后，通常会加上一个偏置，并且将得到的加权和传给激活函数。与全连接网络相比，其最大的区别在于卷积网络的每个神经元重用相同的权重，而不是每个神经元都有自己的权重。

在上面的动画中，你可以看到通过连续修改图片上两个方向的权重（卷积），能够获得与图片上的像素点数量相同的输出值（边缘处需要 padding）。

要产生一个输出值平面，我们使用了一张 4x4 大小的彩色图片作为出输入。在这个动画当中，我们需要 4x4x3=48 个权重。这还不够，为了增加更多自由度，我们还需要选取不同组的权重值重复实验。

![](https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/img/40fd4b6ad8dfb6d2.png)

通过向权重张量添加一个维度，能够将两组或更多组的权重重写为一组权重，这样就给出了一个通用的卷积层权重张量的实现。由于输入、输出通道的数量都是参数，我们可以堆叠和连接卷积层。

![](https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/img/6eff0308ba98370e.png)

最后，我们需要提取出信息。在最后一层中，我们仅仅想使用 10 个神经元来分类 0-9 十个不同的数字。传统上，这是通过**最大池化（max-pooling）**层来完成的。即使今天有许多更简单的方法能够实现这分类任务，但是，max-pooling 能够帮助我们直觉地理解卷积神经网络是怎么工作的。如果你认为在训练的过程中，我们的小块权重会发展成能够过滤基本形状（水平线、垂直线或曲线等）的 filter，那么，提取有用信息的方式就是识别输出层中哪种形状具有最大的强度。实际上，在 max-pooling 层中，神经元的输出是在 2x2 的分组中被处理，最后仅仅保留输出最大强度的神经元。

这里有一种更简单的方法：如果你是以一步两个像素移动图片上的滑块而不是以每步一个像素地移动图片上的滑块。这种方法被证明是有效的，当今的卷积网络仅仅使用了卷积层。

![](https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/img/b6b1f2c1c91158c8.png)

让我们来构建一个用于手写数字识别的卷积网络。在上方，我们将使用 3 个卷积层；在底部，我们使用传统的 softmax 读出层，并将它们用一个完全连接层相连：

![](https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/img/3701df765a81a094.png)

注意，第二与第三卷积层的步长（stride）是2，这就解释了为什么它们的输出值从 28x28 减少为 14x14，然后再到 7x7。卷积层的大小变化使神经元的数量在每层下降约为：28x28x14≈3000 → 14x14x8≈1500 → 7x7x12≈500 → 200。下一节中，我们将给出该网络的具体实现。
